# _______________________________________________________________________________________________
# 
# yt_subititles.py : Preprocessor for generating subtitles
#   Parsesa two-level subtitles input file, that has scenarios and clips under scenarios
#   Generates output to the yt_subtitles file, flattening the input and generating all incremental times.
#    
# Not scenario title line timing are absolute start times for scenario video
#   Video clip start times can be either absolute or incremental. Program figures out which one smartly.
#   
#________________________________________________________________________________________________________

# System utilitites to access files
import os     
import sys

# Standard directory and file names, change paths and names as needed (esp version name)
project_name = "thayagamayi sriramachandra"
project_file_names = "rk"
version_name = "build122"  # subdirectory of project, change this to run on a new version
directory = 'C:\\Users\\schit\\OneDrive\\Documents\\' + project_name + "\\" + version_name + "\\"

# Was done for Ramakathanaka project first time, so named rk and rk1. Change it for future projects
yt_program = "..\\yt_subtitles "  # program is expected to be in project directory.
input_file_name = project_file_names+"_subtitles.txt"  # Should be in version_name subdirectory
clip_start_file_name = project_file_names+"1.clip_start.txt"  # These will be generated by python script below (runs in two pass)
output_file_name = project_file_names+"1_subtitles.txt"  # Output file during second pass, input to yt_subtitles program
log_file_name = project_file_names+"_log.txt"  # File to log run information, Make it empty string, i.e. "", to redirect log to console

# Key words in input file
scenario_keyword = "Scene"
clip_keyword = "Clip"
clip_skip_subtitles = "NT"

# Bulleted subtitles from word documents will result in ?\t when saved as plain text in ASCII encoding.
subtitle_begin_in_input = "?\t"
subtitle_begin_in_output = '>'  # Space is added after this

last_section_in_name = 'Endx'
last_section_out_name = 'END:'
subtitle_end_marker = '----'

# Character names is added in *clip_start.txt file, and is used to generate prefixes for subtitles.
character_names = {'SU1' : 'Narrator', 'SU2' : 'Narrator', 'SE1' : 'Seethe', 'SE2' : 'Seethe', 'LK' : 'Lakshmana', 
                   'VA' : 'Valmiki', 'RA' : 'Rama', 'LV' : 'Lava', 'KU' : 'Kusha', 'MU1' : '', 'MU2' : '',
                   'SR' : 'Summary'}

# Global data extracted from pass 1 and used in pass 2 when input to yt_subtitles program is generated
video_clip_durations = {} # Clip duration per scenario or clip
no_of_subtitles = {}     # No of subtitles per scenario or clip.
clip_granularity = {}   # Boolean, Clips have individual times and character names, indexed by scenario
cur_character = ""
cur_time = 0 
out_st_file = sys.stdout  # Only used in second pass and will be set to *1.subtitles.txt file. 

#________________________________________________________________________________________________
#
# Managing times - times are in m.s floating no format where m is minutes and s is in seconds.
# If times go more than 1 hr, it will not quite work without modification
#________________________________________________________________________________________________

def get_min_sec(time) :  # Given float format of min.sec, return min and seconds
    return(int(time), round((time - int(time)) * 100))
def from_min_sec(m,s) : # Return time as floating no given minutes and seconds
    return(m + round(s/100,2))

def time_add(time1, time2) : # of float format min.sec
    m1,s1 = get_min_sec(time1) 
    m2, s2 = get_min_sec(time2)
    time_in_min, time_in_secs = m1+m2, s1+s2 ;
    if(time_in_secs >= 60) :
        time_in_secs -= 60 ;
        time_in_min += 1 ;
    return(from_min_sec(time_in_min,time_in_secs))
 
def time_diff(time1, time2) :
    m1,s1 = get_min_sec(time1) 
    m2, s2 = get_min_sec(time2)
    time_in_min, time_in_secs = m1-m2, s1-s2 ;
    if(time_in_secs < 0) :
        time_in_secs += 60 ;
        time_in_min -= 1 ;
    return(from_min_sec(time_in_min,time_in_secs))

#_________________________________________________________________________________________
#
# parse_scenario_title_line : process scenario title line
#    Returns scenario no (after keyword Scene) and its start time if given (otherwise -1)
#
#  Scenario title line is of format
#     SceneNO = Txx+Tyy+...  Start_time
#___________________________________________________________________________________________

def parse_scenario_title_line(sce_title_line) :
    # Split the title line into words
    sce_title_line = sce_title_line.split(' ')

    # Remove leading and trailing empty words
    if(len(sce_title_line[0]) <= 0) :
        sce_title_line = sce_title_line[1:]
    if(len(sce_title_line[-1]) <= 0 or len(sce_title_line[-1].strip()) <= 0) : # Trim null word or white spaces in end
        sce_title_line = sce_title_line[:-1]

    # scenario title line should now look like [no time] 
    if(len(sce_title_line) < 2) :  # All scenarios should have at least start time now.
        if(len(sce_title_line[0]) > 1) :
            print(" Scenario does not have time ??, give -1 if scenario video is missing. Skipping  ", sce_title_line)
        cur_sce_time = -1 ;
    else :
        # Check if scenario video is given, if start time is given and not -1.
        if(sce_title_line[-1][0].isdigit() or sce_title_line[-1][0] == '-') :
            cur_sce_time = float(sce_title_line[-1])
        else :
            cur_sce_time = -1
    return(sce_title_line[0],cur_sce_time)

#
# Capture duration of scenario during first pass, by difference of start times
#
def capture_video_duration(prev_scene, prev_clip_end,cur_sce_name, cur_sce_time) :
    # Compute duration for last clip, if time is given for next clip
  
    if(prev_scene != []) :  # Set previous scene or current scene durations.
        if (cur_sce_time > 0) :
            if(prev_scene in video_clip_durations) :
                print(" Duplicate scene name detected , fix to make scenarios have unique names :",cur_sce_name)
            if(cur_sce_time - prev_clip_end <= -0.01) :
                print(" Sceneario start time is not right, earlier than prev scene end :",
                      cur_sce_name,",",cur_sce_time,",",prev_clip_end)
                cur_sce_time = prev_clip_end
            video_clip_durations[prev_scene] = time_diff(cur_sce_time,prev_clip_end)
        else :
            video_clip_durations[cur_sce_name] = 0
    else : # First scene
        if (cur_sce_time < 0) :
            video_clip_durations[cur_sce_name] = 0
        # else first scene start time is zero, as expected, its duration will be set later.

#_______________________________________________________________________________________________________
#
# parse_clip_title_line : Parses clip title line to extract info.
#
#  Clip title line is expected to be (after Clip key word is removed) T/NT Tnn-xxx-cc:  ***  [m.nn]
#         where NT will result in subtitles ignored.
#         nn is Clip no.
#         xxx - Ignored
#         cc  - Character for this clip. Can be two or three characters.
#         m.nn - Optional duration. If given, clips are output else clip titles will be merged with other scenario titles.
#__________________________________________________________________________________________________________

def parse_clip_title_line(clip_title_line) :

    # Skip empty word at beginning
    if(len(clip_title_line[0]) == 0) :
            clip_title_line = clip_title_line[1:]
            
    # Check if clip no is the next clip expected, Clip titles is first word of format Tnn-**-**:
    # First one is clip no, second one is part no, third is character name, can be 2 or 3 chars
    clip_no = int(clip_title_line[1].split('-')[0][1:])  
    
    # Capture character name for title
    cur_character = clip_title_line[1].split('-')[2][:-1]   # Clip titles end with ':', and ':' is ignored.
    if (cur_character in character_names) :
        cur_character = character_names[cur_character]
    else :
        print("Unknown character in clip, ", clip_title_line[1]," : ",cur_character,file=outfile)
        cur_character = ""

    # Mask off titles if "NT" is given after clip name
    clip_titles_enabled =True 
    if(clip_title_line[0] == clip_skip_subtitles) :
        clip_titles_enabled = False

    # Check if clip duration is given, Trim down null words at end
    while len(clip_title_line[-1]) == 0 : 
        clip_title_line = clip_title_line[:-1]
    if(clip_title_line[-1][0].isdigit()) :
        clip_duration = float(clip_title_line[-1])
    else :
        clip_duration = 0

    return(clip_title_line,clip_no, cur_character, clip_duration, clip_titles_enabled )


#______________________________________________________________________________________
#
#  add_clip_subtitles   - Main function which extracts subtitle lines from input file
#         and outputs them as part of merged scenario or individual clip sections.
#  Returns no of subtitles found.
#______________________________________________________________________________________

#
# Process subtitles from an individual clip subtitles, and output them; returns no of subtitles
#    Merges lines that are of the same subtitle (due to wrap_around)
#
def parse_subtitles(subtitles) :
    cur_subtitles = ""
    no_titles = 0
    for x in subtitles :
        if(len(x) == 0) :  # Skip empty lines
            continue 
        if (x[0].isspace()) : # Skip leading space
            x = x[1:]
        if (len(x) < 2 or (x[0] != subtitle_begin_in_input[0] 
                            and not x[0].isdigit())) :  
            # Continuation of same sub-title, word-wrapped
            cur_subtitles = cur_subtitles + x
        else : # new subtitle, Currently bulleted subtitles from Word is saved as '?\t' at beginning
            if(cur_subtitles != "") :  # Go to next line if not first line
                cur_subtitles = cur_subtitles + '\n'
            if(not x[0].isdigit()) :
                x = subtitle_begin_in_output + ' ' + x[len(subtitle_begin_in_input):]
            else :  # Subtitle has incremental time at beginning, check if it is absolute or incremental
                t = x.split()[0]
                st_time = round(float(t),2)
                if(st_time > (cur_time - 0.02)) :  # Clip time is absolute time, convert to incremental.
                    st_time = time_diff(st_time,cur_time)
                    if(st_time < 0) : # Start time is within 1 sec of clip_start time, make it 0 
                        st_time = 0 
                        if(cur_subtitles != "") :
                            print(" Second subtitle or later one is starting 1 sec before clip start time ?? : ", st_time)
                #st = x[len(t)+1:].replace('?',"\'")
                x = f'{st_time:.2f} {x[len(t)+1:]}'
                #x = f'{st_time:.2f} {st}'
            cur_subtitles = cur_subtitles + x
            no_titles += 1
    return(no_titles,cur_subtitles)

def add_clip_subtitles(clip_title_line,subtitles,clip_duration,hdr,out_st_file=sys.stdout,write_titles=True) : 
  
    no_titles, cur_subtitles = parse_subtitles(subtitles)
    # Write last line still in buffer to file
    if(write_titles) :  # Headers for individual clips individual clip start points are not given
        if(hdr) :
            print(clip_title_line[1], clip_duration, no_titles, file=out_st_file)
        if(cur_subtitles != "") :
            print(cur_subtitles,file=out_st_file)
        if(hdr) :
            print(subtitle_end_marker,file=out_st_file)
    return(no_titles)

#________________________________________________________________________________________________________________
#
# Main function to process input file content - st_content, called twice.
#
#  st_content is 2-level list split by scenarios and clips within it
#  generate_timing : False first time, true second time
#  include_scene_line : Prints scenario lines, only enable during first pass to enable debug
#  include_clips_without_time : Prints clip lines even if its subtitles are getting merged with other clips in scenario
#                   only set to true in first pass when generate_timing = False
#  add_char_prefix : Adds character names to the clip_start file generated, so yt_subtitles program can add that
#        as prefix to all subtitles in that video clip (only one character per clip)
#__________________________________________________________________________________________________________________

def last_sce_name(cur_sce_name, generate_timing) :
    global no_of_subtitles, video_clip_durations, clip_granularity, cur_character, cur_time, out_st_file, outfile
    video_clip_durations[cur_sce_name] = 0
    no_of_subtitles[cur_sce_name] = 0 
    clip_granularity[cur_sce_name] = False
    if(generate_timing) :  # Put last section marker
        cur_min,cur_sec = get_min_sec(cur_time)
        #print(f'{cur_min}:{cur_sec} Scene-{cur_sce_name} - {cur_character}' , file=outfile) 
        closing_str = subtitle_end_marker + "\n" + last_section_out_name + " -1 -1 \n" + subtitle_end_marker + "\n" 
        print(closing_str,file=out_st_file)

#
# Output scenario title lines into timing file (*1_subtitles.txt and/or output file *.clip_start file)
#   only called if video for scenario exists in this build.
#

def out_next_scenario_title(cur_sce_name, generate_timing,include_scene_line) :
    global no_of_subtitles, video_clip_durations, clip_granularity, cur_character, cur_time,  outfile
    cur_min,cur_sec = get_min_sec(cur_time)
    if(generate_timing and not clip_granularity[cur_sce_name]) :  # Print clip title line into timing (subtitles) file
        print(f'Scene-{cur_sce_name}: {video_clip_durations[cur_sce_name]:2.2f} {no_of_subtitles[cur_sce_name]:2}',
                file=out_st_file)
        if(not clip_granularity[cur_sce_name]) :  # If clip times listed, they will be generated already
            # Add entry to clip_start file
            print(f'{cur_min}:{cur_sec} Scene-{cur_sce_name}', file=outfile)
    if(include_scene_line) :  # For debug only
        if not generate_timing : # First pass, only know scenario name, and start time
            print(f'{cur_min}:{cur_sec} Scene-{cur_sce_name}', file=outfile)
        else :  # Second pass, know duration and no of subtitles also.
            # This case is prevented if include_scene_line is set to false when generate_timing = True
            print(f'{cur_min}:{cur_sec} Scene-{cur_sce_name} {video_clip_durations[cur_sce_name]:2.2f} \
{no_of_subtitles[cur_sce_name]:2}', file=outfile)

#
# Generates a clip title line in out file, called only if clip_granularity for this scenario
#     or enabled for debug
#
def out_next_clip_title(clip_title_line) :
    global no_of_subtitles, video_clip_durations, clip_granularity, cur_character, cur_time, out_st_file, outfile
    cur_min,cur_sec = get_min_sec(cur_time)
    if(len(clip_title_line) > 2) :
        # Clip duration given, currently all are within an hr
        st_index = 0 
        if clip_title_line[1][0] == ' ' :  # Leading space ? Should not be true ??
            st_index = 1
        print(f'{cur_min}:{cur_sec:2.2f} {clip_title_line[1][st_index:-1]} - {cur_character}' , file=outfile)  
    else :  # Clip duration not given
        if include_clips_without_time :
            if (len(clip_title_line) == 2) :
                print(f'{cur_min}:{cur_sec:2.2f} {clip_title[1]} ', file=outfile)
            else :
                print(f'{cur_min}:{cur_sec:2.2f} clip_title not given ?? : {clip_title[0]}', file=outfile)

def gen_subtitles(st_content, generate_timing, include_scene_line = False, include_clips_without_time =False,add_char_prefix=True) :
    global no_of_subtitles, video_clip_durations, clip_granularity, cur_character, cur_time, out_st_file, outfile
    
    # Get ready to process
    cur_time, cur_clip, prev_scene, prev_clip_end, out_st_file = 0,0,[],0,sys.stdout
    if(generate_timing) :
        # include_scene_line = include_clips_without_time = False
        out_st_file = open(directory + output_file_name,'w')  # Note timing file is overwritten
    
    # Process each scenario
    for scenario in st_content :
        # 0. Skip entire scenario if expected title line does not exist
        if(not type(scenario) == list or len(scenario[0]) < 1) : # No clips in scenario ?? Skip
            if(scenario != [""]) :
                print(" Skipping non-scenario texts : ", scenario, file=outfile)
            continue

        # 1. Parse scenario title line, which is first line 
        cur_sce_name, cur_sce_time = parse_scenario_title_line(scenario[0])
        orig_cur_sce_time = cur_sce_time
        
        # 2. Capture video duration and set current time, for start of current scenario
        if(not generate_timing) :
             capture_video_duration(prev_scene,prev_clip_end, cur_sce_name,cur_sce_time)
        if(cur_sce_time < 0) :  # Video not included yet, skip and continue
            cur_sce_time, video_missing = prev_clip_end, True  # cur_time is also prev_clip_end at this point
        else :
            cur_time, video_missing = cur_sce_time, False
            if(prev_scene == [] and cur_time != 0 and print_warning) :
                print(" First scenario with video is not starting at time 0 ?? ", cur_sce_name,file=outfile)
            
        # 3. Output scenario title line into outfile (for log) and timing file if that is being generated
        if (not video_missing and (include_scene_line or generate_timing)) :
            out_next_scenario_title(cur_sce_name, generate_timing,include_scene_line)        
        
        # 4. Last scenario marker, output it and exit
        if(cur_sce_name == last_section_in_name) :
             last_sce_name(cur_sce_name, generate_timing)
             break ;
        
        # 5. Process each clips inside scenario 
        no_titles,cur_character = 0, ""
        if(not generate_timing) :
            clip_granularity[cur_sce_name] = False
        for clip in scenario[1:] :
            # A. Split clip subtitles into individual lines
            clip = clip.split('\n')  # Split subtitles by lines
            clip_title_line = clip[0].split(' ')  # First line is the clip title line.
            clip_subtitles = clip[1:]

            # B. Process clip_title_line
            clip_title_line,clip_no, cur_character, clip_duration, clip_titles_enabled = parse_clip_title_line(clip_title_line) 
            if(clip_no != cur_clip+1 and clip_no != cur_clip and print_warning) : # Clip nos can repeat.
                print("Clip missing ? ", cur_clip+1,clip_no+1 )
            cur_clip = clip_no 
            if(clip_duration > 0 ) :
                clip_granularity[cur_sce_name] = True
            else :  # Clip granularity should be false, which is the default value
                if(clip_granularity[cur_sce_name] == True) :
                    print(" All clips should have time or no-time, consistent in scenario ",cur_sce_name )
            
            # C.    If clip_duration is given or asked for debug, list_out clips seperately 
            if(clip_granularity[cur_sce_name] or include_clips_without_time) :
                out_next_clip_title(clip_title_line)           
                   
            # D. Output the subtitles in clip - either with its own header or as part of scenario. 
            #    They will be skipped if NT keyword exists after Clip keyword in title line.
            if(not video_missing) :
                no_titles += add_clip_subtitles(clip_title_line,clip_subtitles,clip_duration,hdr=clip_granularity[cur_sce_name],
                               out_st_file=out_st_file, write_titles = generate_timing)

            # E. Advance cur_time before next clip
            if(clip_duration > 0) : # Advance current time if clip durations are given for this scenario
                cur_time = time_add(cur_time,clip_duration)
        
        # At end of scenario
        if(not video_missing) :
            if(generate_timing) : # put delimiter if scenario had subtitles
                if(not clip_granularity[cur_sce_name]) :  # If clip level granularity, end_marker would be generated already
                    print(subtitle_end_marker, file=out_st_file)
                if (no_titles != no_of_subtitles[cur_sce_name]) :  
                    # This should not happen now as both passes uses same function to determine no of subtitles
                    print(" No of subtitles mismatch for scenario, code error ?", cur_sce_name, " : ",
                          no_titles,no_of_subtitles[cur_sce_name],file=outfile)
            else :  # First pass, capture no of subtitles to write in second pass.
                no_of_subtitles[cur_sce_name] = no_titles
               
        prev_clip_end = cur_time 
        if(orig_cur_sce_time >= 0 ) :  # Remember to find duration for this one as you process further.
           prev_scene = cur_sce_name

        if(generate_timing and out_st_file != sys.stdout) :  # Commit the progress so far to output file (*1_subtitles.txt)
            out_st_file.close()
            out_st_file = open(directory + output_file_name,'a')

    if(generate_timing and out_st_file != sys.stdout) :
        out_st_file.close()


#____________________________________________________________________________________________________
#
# Run through content in two passes, first pass will collect information
#   and second pass will generate the subtitle output for yt_subtitles program
#________________________________________________________________________________________________

# Not used any longer, but can be used to debug if read is failing
def read_content (f) :
    st_content = ""
    l = f.readline()
    x = 1
    while x <= 678 :
        st_content = st_content + l.decode()
        #st_content = st_content+l+"\n"
        l = f.readline()
        x = x+1
    return(st_content)
            
        #print(st_content[6720:6740])
def main_flow (directory, input_file_name, output_file_name, clip_start_file_name, log_file_name) :
    global outfile, print_warning, yt_program, scenario_keyword, clip_keyword

    # 1. Open input file that has subtitles under scene or video clips, and created a 2-level list
    with open(directory + input_file_name,'rb') as f :
        st_content = f.read().decode() # Reads the file as binary to keep characters > 0x7f, and converts to UTF-8 encoding string.
        st_content = list(map(lambda l : l.split(clip_keyword) , st_content.split(scenario_keyword)))

    # 2. Parse the input, capture information, log information to stdout including warnings
    print(" First pass of processing .. :")
    # redirect output to log file or console
    if log_file_name == "" :
        outfile = sys.stdout
    else :
        outfile = open(directory + log_file_name,'w')
    print_warning = True
    gen_subtitles(st_content,False,include_scene_line=True)  # First pass
    if outfile != sys.stdout :
        outfile.close()

    #    
    # Second pass - run silently, generate clip start time info into clip_start file, and
    #   subtitles input file to yt_subtitles program. Subtitle file is opened and closed in gen_subtitles function.
    #
    print("Second pass of processing ...: ")
    outfile = open(directory + clip_start_file_name,'w')  # overwrites the file
    print_warning = False  # Runs silently and generating *clip_start.txt file.
    gen_subtitles(st_content,True)  # Second pass
    if(outfile != sys.stdout) :
        outfile.close()

    # Third step : run yt_myfinpro C++ program to generate Youtube input file - *subtitles_timings.txt
    #   Note C== program, yt_subtitles, is expected to be in project directory (one level above versions)
    #   C++ program also generates *section_details.txt file which is summary of various clips.
    print("running yt_subtitles program to generate Youtube input file")
    os.chdir(directory)
    in_file = output_file_name[:output_file_name.rfind('_')]
    if log_file_name == "" :
        os.system(yt_program+" -p "+in_file)
    else :
        os.system(yt_program+" -lp "+in_file)

main_flow (directory, input_file_name, output_file_name, clip_start_file_name, log_file_name)